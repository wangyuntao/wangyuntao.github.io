[{"content":"","href":"/posts/","title":"文章"},{"content":"记录下日常的技术细节\n","href":"/%E5%85%B3%E4%BA%8E/","title":"关于"},{"content":" 本博客的内容也会同步到我的微信公众号，欢迎大家关注。\n微信公众号: ytcode\n ","href":"/","title":"\u003e "},{"content":"","href":"/authors/","title":"Authors"},{"content":"","href":"/categories/","title":"Categories"},{"content":"","href":"/tags/git/","title":"Git"},{"content":"","href":"/categories/git%E7%A4%BA%E4%BE%8B%E6%95%99%E7%A8%8B/","title":"Git示例教程"},{"content":"相关命令：\n# 图形化显示当前分支的提交日志 git log --graph --oneline # 图形化显示当前分支的提交日志及每次提交的变更内容 git log --graph --patch # 图形化显示所有分支的提交日志 git log --graph --oneline --all # 图形化显示所有分支的提交日志及每次提交的变更内容 git log --graph --patch --all 效果演示：\n我们先用下面的命令创建一个测试用的Git仓库：\n# 创建一个空的Git仓库 mkdir repo \u0026amp;\u0026amp; cd repo \u0026amp;\u0026amp; git init # master分支提交m1 echo m1 \u0026gt; m1.txt \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m m1 # b分支提交b1、b2 git checkout -b b echo b1 \u0026gt; b1.txt \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m b1 echo b2 \u0026gt; b2.txt \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m b2 # 切换到master分支 git checkout master # master分支提交m2 echo m2 \u0026gt; m2.txt \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m m2 # 合并b分支 git merge b --no-edit # master分支提交m3、m4 echo m3 \u0026gt; m3.txt \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m m3 echo m4 \u0026gt; m4.txt \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m m4 # b分支提交b3、b4 git checkout b echo b3 \u0026gt; b3.txt \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m b3 echo b4 \u0026gt; b4.txt \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m b4 # 切换到master分支 git checkout master 先看下当前分支提交日志的图形化效果：\n$ git -P log --graph --oneline * 1b95716 (HEAD -\u0026gt; master) m4 * 9629016 m3 * 960ae54 Merge branch \u0026#39;b\u0026#39; |\\ | * 5c4e7a0 b2 | * 82e6569 b1 * | cec7a59 m2 |/ * 3706b17 m1 再看下所有分支提交日志的图形化效果：\n$ git -P log --graph --oneline --all * 85cf84a (b) b4 * 6c72eb7 b3 | * 1b95716 (HEAD -\u0026gt; master) m4 | * 9629016 m3 | * 960ae54 Merge branch \u0026#39;b\u0026#39; | |\\ | |/ |/| * | 5c4e7a0 b2 * | 82e6569 b1 | * cec7a59 m2 |/ * 3706b17 m1 最后看下当前分支每次提交的变更内容：\n$ git -P log --graph --patch * commit 1b9571692938cae69e4cb6f1c90195629b99ee14 (HEAD -\u0026gt; master) | Author: wangyuntao \u0026lt;wyt.daily@gmail.com\u0026gt; | Date: Tue Oct 29 17:58:06 2019 +0800 | | m4 | | diff --git a/m4.txt b/m4.txt | new file mode 100644 | index 0000000..995fb87 | --- /dev/null | +++ b/m4.txt | @@ -0,0 +1 @@ | +m4 | * commit 96290165e6cf0869a7cb5f74dd84596e5b156017 | Author: wangyuntao \u0026lt;wyt.daily@gmail.com\u0026gt; | Date: Tue Oct 29 17:58:06 2019 +0800 | | m3 | | diff --git a/m3.txt b/m3.txt | new file mode 100644 | index 0000000..e5c9ce9 | --- /dev/null | +++ b/m3.txt | @@ -0,0 +1 @@ | +m3 | * commit 960ae547f7751191c9d30e17eac2fbb85589d778 |\\  Merge: cec7a59 5c4e7a0 | | Author: wangyuntao \u0026lt;wyt.daily@gmail.com\u0026gt; | | Date: Tue Oct 29 17:58:06 2019 +0800 | | | | Merge branch \u0026#39;b\u0026#39; | | | * commit 5c4e7a015a519e60134fe2d7895590a756887d4b | | Author: wangyuntao \u0026lt;wyt.daily@gmail.com\u0026gt; | | Date: Tue Oct 29 17:58:06 2019 +0800 | | | | b2 | | | | diff --git a/b2.txt b/b2.txt | | new file mode 100644 | | index 0000000..e6bfff5 | | --- /dev/null | | +++ b/b2.txt | | @@ -0,0 +1 @@ | | +b2 | | | * commit 82e6569460ce15d46b5f7d44fa4b68080bf952a6 | | Author: wangyuntao \u0026lt;wyt.daily@gmail.com\u0026gt; | | Date: Tue Oct 29 17:58:06 2019 +0800 | | | | b1 | | | | diff --git a/b1.txt b/b1.txt | | new file mode 100644 | | index 0000000..c9c6af7 | | --- /dev/null | | +++ b/b1.txt | | @@ -0,0 +1 @@ | | +b1 | | * | commit cec7a592810edb921e602c214881e3e8d37bb449 |/ Author: wangyuntao \u0026lt;wyt.daily@gmail.com\u0026gt; | Date: Tue Oct 29 17:58:06 2019 +0800 | | m2 | | diff --git a/m2.txt b/m2.txt | new file mode 100644 | index 0000000..08bb233 | --- /dev/null | +++ b/m2.txt | @@ -0,0 +1 @@ | +m2 | * commit 3706b17072a7eb78f8093b36774c63fbcd9dc106 Author: wangyuntao \u0026lt;wyt.daily@gmail.com\u0026gt; Date: Tue Oct 29 17:58:06 2019 +0800 m1 diff --git a/m1.txt b/m1.txt new file mode 100644 index 0000000..63a911f --- /dev/null +++ b/m1.txt @@ -0,0 +1 @@ +m1 以上命令是不是比直接用git log命令直观多了呢？\n好了，命令行中图形化显示提交日志的内容到这里就结束了，希望对你有所帮助。\n","href":"/posts/git/log_graph/","title":"Git示例教程 - 命令行中图形化显示提交日志"},{"content":"","href":"/tags/","title":"Tags"},{"content":"","href":"/authors/wangyuntao/","title":"wangyuntao"},{"content":"相关命令：\n# 遍历本地仓库中的所有分支，如果该分支在远程仓库中不存在，则在远程仓库中创建该分支 # 遍历远程仓库中的所有分支，如果该分支在本地仓库中不存在，则在远程仓库中删除该分支 git push --all --prune # 遍历远程仓库中的所有分支，如果该分支在本地仓库中没有对应的远程追踪分支，则在本地仓库中创建该分支 # 遍历本地仓库中的所有远程追踪分支，如果该分支在远程仓库中没有对应的分支，则将其删除 git fetch --prune 情景模拟：\n为了方便测试，我们先在GitHub上创建一个名为git-test-repo的仓库，然后将其克隆到本地，之后，我们再用相应的命令创建一个测试分支，并将其同步到远端，具体命令如下：\n$ git clone https://github.com/wangyuntao/git-test-repo.git repo1 # 省略输出 # $ cd repo1 $ git push origin master:b3 # 创建一个远程分支b3 # 省略输出 # $ git -P branch -avv # 查看当前分支状态 * master ab5a63d [origin/master] Initial commit remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/b3 ab5a63d Initial commit remotes/origin/master ab5a63d Initial commit 我们再打开一个终端，将该仓库再克隆一份到本地备用：\n$ git clone https://github.com/wangyuntao/git-test-repo.git repo2 # 省略输出 # $ cd repo2 $ git -P branch -avv * master ab5a63d [origin/master] Initial commit remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/b3 ab5a63d Initial commit remotes/origin/master ab5a63d Initial commit 现在我们回到repo1中，执行下面的命令：\n$ git branch b1 # 创建本地分支b1 $ git branch b2 # 创建本地分支b2 $ git push --all --prune # 将本地分支的添加删除状态同步到远程 Total 0 (delta 0), reused 0 (delta 0) To https://github.com/wangyuntao/git-test-repo.git - [deleted] b3 * [new branch] b1 -\u0026gt; b1 * [new branch] b2 -\u0026gt; b2 $ git -P branch -avv # 查看当前的分支状态 b1 ab5a63d Initial commit b2 ab5a63d Initial commit * master ab5a63d [origin/master] Initial commit remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/b1 ab5a63d Initial commit remotes/origin/b2 ab5a63d Initial commit remotes/origin/master ab5a63d Initial commit 由上可见，因为本地仓库中没有b3分支，所以 git push \u0026ndash;all \u0026ndash;prune 命令删除了远程仓库中的b3分支，又因为本地仓库中新建了b1和b2分支，所以该命令在远程仓库中也创建了这两个分支。\n现在我们再切换到repo2，执行下面的命令：\n$ git branch b3 origin/b3 # 创建远程追踪分支origin/b3的本地分支b3 Branch \u0026#39;b3\u0026#39; set up to track remote branch \u0026#39;b3\u0026#39; from \u0026#39;origin\u0026#39;. $ git -P branch -avv b3 ab5a63d [origin/b3] Initial commit * master ab5a63d [origin/master] Initial commit remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/b3 ab5a63d Initial commit remotes/origin/master ab5a63d Initial commit $ git fetch --prune # 将远程分支的添加删除状态同步到本地 From https://github.com/wangyuntao/git-test-repo - [deleted] (none) -\u0026gt; origin/b3 * [new branch] b1 -\u0026gt; origin/b1 * [new branch] b2 -\u0026gt; origin/b2 $ git -P branch -avv b3 ab5a63d [origin/b3: gone] Initial commit * master ab5a63d [origin/master] Initial commit remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/b1 ab5a63d Initial commit remotes/origin/b2 ab5a63d Initial commit remotes/origin/master ab5a63d Initial commit 由上可见，因为远程仓库中的b3分支被删除，并且又创建了b1和b2分支，所以 git fetch \u0026ndash;prune 命令删除了本地仓库中的远程追踪分支 origin/b3（但没有删除本地分支b3），并创建了远程追踪分支 origin/b1 和 origin/b2。\n到这里，有关本地仓库和远程仓库分支添加删除状态的同步就讲完了，希望对你有所帮助。\n","href":"/posts/git/branch_sync/","title":"Git示例教程 - 同步本地分支的添加删除状态到远程（或反之）"},{"content":"相关命令：\ngit branch -d 要删除的分支 # 删除本地分支 git branch -D 要删除的分支 # 强制删除本地分支 git push -d origin 要删除的分支 # 删除远程分支 情景模拟：\n为了方便测试，我们先在GitHub上创建一个名为git-test-repo的仓库，然后将其克隆到本地，并看下其当前的分支情况：\n$ git clone https://github.com/wangyuntao/git-test-repo.git Cloning into 'git-test-repo'... # 省略部分输出 # $ cd git-test-repo $ git -P branch -avv * master ab5a63d [origin/master] Initial commit remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/master ab5a63d Initial commit  由上可见，该仓库目前只有本地分支master，其对应的远程分支为origin/master（就是该仓库在GitHub上的master分支）。\n下面我们用上一篇文章中介绍过的命令，创建一个测试分支，并同步到远端：\n$ git branch b1 $ git push --set-upstream origin b1 # 省略输出 # $ git -P branch -avv b1 ab5a63d [origin/b1] Initial commit * master ab5a63d [origin/master] Initial commit remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/b1 ab5a63d Initial commit remotes/origin/master ab5a63d Initial commit 由上可见，我们创建了一个本地分支b1，然后将其同步到了GitHub上（orgin/b1）。\n下面我们来测试下对应的删除命令。\n先删除本地分支：\n$ git branch -d b1 # 删除本地分支b1 Deleted branch b1 (was ab5a63d). $ git -P branch -avv # 查看当前分支情况 * master ab5a63d [origin/master] Initial commit remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/b1 ab5a63d Initial commit remotes/origin/master ab5a63d Initial commit 由上可见，本地的b1分支已经没有了，但其对应的远程分支origin/b1还在。\n我们再用下面的命令删除其对应的远程分支：\n$ git push -d origin b1 # 删除远端的b1分支 To https://github.com/wangyuntao/git-test-repo.git - [deleted] b1 $ git -P branch -avv # 查看当前的分支情况 * master ab5a63d [origin/master] Initial commit remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/master ab5a63d Initial commit 由上可见，b1对应的远程分支origin/b1也被删除了，此时如果我们到GitHub上看一下的话，也会发现，b1分支已经没有了。\n好了，到这里有关本地分支及远程分支的删除操作就已经讲完了，希望对你有所帮助。\n","href":"/posts/git/delete_branch/","title":"Git示例教程 - 删除本地分支及远程分支"},{"content":"相关命令：\ngit branch 新分支名 # 基于当前分支创建一个新分支 git push --set-upstream origin 新分支名 # 将新分支推送到远端 情景模拟：\n为了方便测试，我们先在GitHub上创建一个名为git-test-repo的仓库，然后将其克隆到本地，并看下其当前的分支情况：\n$ git clone https://github.com/wangyuntao/git-test-repo.git Cloning into \u0026#39;git-test-repo\u0026#39;... # 省略部分输出 # $ cd git-test-repo $ git -P branch -avv * master ab5a63d [origin/master] Initial commit remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/master ab5a63d Initial commit 由上可见，该仓库目前有个本地分支master，其对应的远程分支为origin/master（就是该仓库在GitHub上的master分支）。\n现在我们基于master分支，再创建一个分支b1：\n$ git branch b1 # 创建分支b1 $ git -P branch -avv # 查看当前分支情况 b1 ab5a63d Initial commit * master ab5a63d [origin/master] Initial commit remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/master ab5a63d Initial commit 由上可见，该仓库现在多了一个本地分支b1，但其目前并没有对应的远程分支。\n下面我们用git push命令，为b1创建一个远程分支。\n$ git push --set-upstream origin b1 # 将本地b1分支推送到远端 # 省略输出 # $ git -P branch -avv # 查看当前分支情况 b1 ab5a63d [origin/b1] Initial commit * master ab5a63d [origin/master] Initial commit remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/b1 ab5a63d Initial commit remotes/origin/master ab5a63d Initial commit 由上可见，在执行完上面的git push命令后，本地b1分支就有了对应的远程分支origin/b1。\n此时，如果我们到GitHub上的仓库去看下的话，也是能找到这个分支的。\n这样，一个本地分支对应的远程分支就创建成功了。\n","href":"/posts/git/create_branch/","title":"Git示例教程 - 创建本地分支及远程分支"},{"content":"如果只是修改上次提交的日志，可以直接使用下面的命令：\ngit commit --amend -m 新的提交日志 如果上次提交的内容有误或者不全，想要修改上次提交中文件的内容，或是添加新的文件，可以执行下面的命令：\n# 先修改对应的文件 # git add 修改的文件或新文件 # 执行下面的命令，将这次修改的内容合并到上次提交 git commit --amend --no-edit 情景模拟：\n先使用下面的命令初始化一个测试用的Git仓库：\n# 初始化一个空的Git仓库 mkdir repo \u0026amp;\u0026amp; cd repo git init # 将a.txt加入到版本控制中 echo A1 \u0026gt; a.txt git add . git commit -m 1 执行完上面的命令后，你发现提交的日志不太友好，想要修改下，可以使用下面的命令：\n$ git commit --amend -m 正确的日志 [master e80dc2f] 正确的日志 Date: Wed Oct 23 17:17:41 2019 +0800 1 file changed, 1 insertion(+) create mode 100644 a.txt $ git -P log --pretty=oneline --abbrev-commit # 确认日志是修改了 e80dc2f (HEAD -\u0026gt; master) 正确的日志 由上可见，通过上面的命令，上次提交的日志信息得到了修复。\n假设我们又发现上次提交的a.txt文件里的内容是错的，且忘了提交b.txt文件，我们可以使用下面的命令修复上次提交：\n$ echo A2 \u0026gt; a.txt # 修复a.txt文件的内容 $ echo B1 \u0026gt; b.txt # 新建b.txt文件 $ git add . # 标记a.txt和b.txt都将在下次commit时提交 $ git commit --amend --no-edit # 将这次提交的内容合并到上次提交中 # 省略输出内容 # $ git -P log --pretty=oneline --abbrev-commit # 查看Git日志，确认只有一条 4f2b621 (HEAD -\u0026gt; master) 正确的日志 $ git -P log -p # 确认修复后的提交包含了我们刚刚做的修改 commit 4f2b621800332c0731f5340dc3a7945a09baf8b9 (HEAD -\u0026gt; master) Author: wangyuntao \u0026lt;wyt.daily@gmail.com\u0026gt; Date: Wed Oct 23 17:17:41 2019 +0800 正确的日志 diff --git a/a.txt b/a.txt new file mode 100644 index 0000000..3ce238a --- /dev/null +++ b/a.txt @@ -0,0 +1 @@ +A2 diff --git a/b.txt b/b.txt new file mode 100644 index 0000000..a19a027 --- /dev/null +++ b/b.txt @@ -0,0 +1 @@ +B1 由上可见，git comit \u0026ndash;amend -no-edit 命令将我们新的修改合并到了上一次提交中。\n","href":"/posts/git/modify_last_commit/","title":"Git示例教程 - 修改上次提交"},{"content":"最终命令：\ngit reset HEAD^ # 上次提交内容会被保存到工作目录 git reset --hard HEAD^ # 上次提交内容会被直接丢弃 情景模拟：\n先使用下面的命令初始化一个测试用的Git仓库：\n# 初始化一个空的Git仓库 mkdir repo \u0026amp;\u0026amp; cd repo git init # 将a.txt加入到版本控制中 echo A1 \u0026gt; a.txt git add . git commit -m 1 # 将a.txt的内容修改为A2并提交 echo A2 \u0026gt; a.txt git commit -am 2 执行完上面的命令后，看下当前的Git日志：\n$ git -P log --pretty=oneline --abbrev-commit 4490479 (HEAD -\u0026gt; master) 2 bf92587 1 假设我们想撤销上次提交，但上次提交的内容不丢弃，可以使用下面的命令：\n$ git reset HEAD^ Unstaged changes after reset: M a.txt $ git -P log --pretty=oneline --abbrev-commit bf92587 (HEAD -\u0026gt; master) 1 $ cat a.txt A2 由上可见，reset命令撤销了上次提交，并把这次提交的内容保存到了工作目录。\n如果我们想撤销上次提交，并且丢弃上次提交修改的内容，可以用另外一条reset命令，这个就不在这里演示了，有兴趣的同学可以自己试下。\n","href":"/posts/git/undo_last_commit/","title":"Git示例教程 - 撤销上次提交"},{"content":"最终命令：\ngit checkout HEAD a.txt # 撤销对a.txt文件的修改 git restore --source=HEAD --staged --worktree a.txt # 也可以使用这个命令 情景模拟：\n先使用下面的命令初始化一个测试用的Git仓库：\n# 初始化一个空的Git仓库 mkdir repo \u0026amp;\u0026amp; cd repo git init # 将a.txt加入到版本控制中 echo A1 \u0026gt; a.txt git add . git commit -m init # 修改a.txt，并把这次修改加入到Git的staging area中 echo A2 \u0026gt;\u0026gt; a.txt git add . # 修改a.txt，不把这次修改加入到Git的staging area中 echo A3 \u0026gt;\u0026gt; a.txt 执行完上面的命令后，看下该Git仓库的当前状态：\n$ git status On branch master Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: a.txt Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git restore \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: a.txt 现在我们想撤销对a.txt文件的修改，可执行如下命令：\n$ git checkout HEAD a.txt Updated 1 path from b5ab058 $ git status On branch master nothing to commit, working tree clean $ cat a.txt A1 由上可见，checkout命令撤销了对a.txt文件的所有修改，包括staging area中的修改。\n","href":"/posts/git/undo_changes_to_one_file/","title":"Git示例教程 - 撤销对单个文件的修改"},{"content":"最终命令：\n$ git reset --hard # 撤销所有文件的修改（不算未进入版本控制的文件） $ git clean -fd # 删除所有未进入版本控制的文件 下面用一个例子展示下这两个命令的使用。\n先用下面的命令初始化一个测试用的Git仓库：\n$ mkdir repo $ cd repo $ git init # 初始化一个空Git仓库 $ echo a \u0026gt; f1.txt $ git add . $ git commit -m f1 # 将f1.txt加入到版本控制中 $ echo b \u0026gt; f1.txt # 修改f1.txt的内容 $ touch f2.txt # 创建新文件f2.txt，其并未进入到版本控制中 执行完上面的命令后，我们已经有了一个可供测试的Git仓库。\n再用下面的命令看下文件的变化情况：\n$ git status -s M f1.txt ?? f2.txt $ git -P diff diff --git a/f1.txt b/f1.txt index 7898192..6178079 100644 --- a/f1.txt +++ b/f1.txt @@ -1 +1 @@ -a +b 由上可见，f1.txt的内容由a变为了b，f2.txt是新创建的，还未进入到版本控制中。\n现在执行上面的撤销命令，看下是如何撤销修改的：\n$ git reset --hard HEAD is now at 5b3c640 f1 $ git status -s ?? f2.txt $ git clean -fd Removing f2.txt $ git status On branch master nothing to commit, working tree clean 由上可见，执行完reset命令后，f1.txt文件的修改被撤销，但f2.txt文件还在。\n执行完clean命令后，f2.txt文件也不在了。\n至此，两条命令撤销了对所有文件的修改，Git仓库回到了原始状态。\n","href":"/posts/git/undo_changes_to_all_files/","title":"Git示例教程 - 撤销对所有文件的修改"},{"content":"","href":"/page/","title":"Pages"},{"content":"","href":"/search/","title":"Search"},{"content":"","href":"/series/","title":"Series"}]
