[{"content":"","href":"/posts/","title":"文章"},{"content":"记录下日常的技术细节\n","href":"/%E5%85%B3%E4%BA%8E/","title":"关于"},{"content":" 本博客的内容也会同步到我的微信公众号，欢迎大家关注。\n微信公众号: ytcode\n ","href":"/","title":"\u003e "},{"content":"","href":"/authors/","title":"Authors"},{"content":"","href":"/categories/","title":"Categories"},{"content":"","href":"/tags/git/","title":"Git"},{"content":"","href":"/categories/git%E7%A4%BA%E4%BE%8B%E6%95%99%E7%A8%8B/","title":"Git示例教程"},{"content":"相关命令：\n# 遍历本地仓库中的所有分支，如果该分支在远程仓库中不存在，则在远程仓库中创建该分支 # 遍历远程仓库中的所有分支，如果该分支在本地仓库中不存在，则在远程仓库中删除该分支 git push --all --prune # 遍历远程仓库中的所有分支，如果该分支在本地仓库中没有对应的远程追踪分支，则在本地仓库中创建该分支 # 遍历本地仓库中的所有远程追踪分支，如果该分支在远程仓库中没有对应的分支，则将其删除 git fetch --prune 情景模拟：\n为了方便测试，我们先在GitHub上创建一个名为git-test-repo的仓库，然后将其克隆到本地，之后，我们再用相应的命令创建一个测试分支，并将其同步到远端，具体命令如下：\n$ git clone https://github.com/wangyuntao/git-test-repo.git repo1 # 省略输出 # $ cd repo1 $ git push origin master:b3 # 创建一个远程分支b3 # 省略输出 # $ git -P branch -avv # 查看当前分支状态 * master ab5a63d [origin/master] Initial commit remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/b3 ab5a63d Initial commit remotes/origin/master ab5a63d Initial commit 我们再打开一个终端，将该仓库再克隆一份到本地备用：\n$ git clone https://github.com/wangyuntao/git-test-repo.git repo2 # 省略输出 # $ cd repo2 $ git -P branch -avv * master ab5a63d [origin/master] Initial commit remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/b3 ab5a63d Initial commit remotes/origin/master ab5a63d Initial commit 现在我们回到repo1中，执行下面的命令：\n$ git branch b1 # 创建本地分支b1 $ git branch b2 # 创建本地分支b2 $ git push --all --prune # 将本地分支的添加删除状态同步到远程 Total 0 (delta 0), reused 0 (delta 0) To https://github.com/wangyuntao/git-test-repo.git - [deleted] b3 * [new branch] b1 -\u0026gt; b1 * [new branch] b2 -\u0026gt; b2 $ git -P branch -avv # 查看当前的分支状态 b1 ab5a63d Initial commit b2 ab5a63d Initial commit * master ab5a63d [origin/master] Initial commit remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/b1 ab5a63d Initial commit remotes/origin/b2 ab5a63d Initial commit remotes/origin/master ab5a63d Initial commit 由上可见，因为本地仓库中没有b3分支，所以 git push \u0026ndash;all \u0026ndash;prune 命令删除了远程仓库中的b3分支，又因为本地仓库中新建了b1和b2分支，所以该命令在远程仓库中也创建了这两个分支。\n现在我们再切换到repo2，执行下面的命令：\n$ git branch b3 origin/b3 # 创建远程追踪分支origin/b3的本地分支b3 Branch \u0026#39;b3\u0026#39; set up to track remote branch \u0026#39;b3\u0026#39; from \u0026#39;origin\u0026#39;. $ git -P branch -avv b3 ab5a63d [origin/b3] Initial commit * master ab5a63d [origin/master] Initial commit remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/b3 ab5a63d Initial commit remotes/origin/master ab5a63d Initial commit $ git fetch --prune # 将远程分支的添加删除状态同步到本地 From https://github.com/wangyuntao/git-test-repo - [deleted] (none) -\u0026gt; origin/b3 * [new branch] b1 -\u0026gt; origin/b1 * [new branch] b2 -\u0026gt; origin/b2 $ git -P branch -avv b3 ab5a63d [origin/b3: gone] Initial commit * master ab5a63d [origin/master] Initial commit remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/b1 ab5a63d Initial commit remotes/origin/b2 ab5a63d Initial commit remotes/origin/master ab5a63d Initial commit 由上可见，因为远程仓库中的b3分支被删除，并且又创建了b1和b2分支，所以 git fetch \u0026ndash;prune 命令删除了本地仓库中的远程追踪分支 origin/b3（但没有删除本地分支b3），并创建了远程追踪分支 origin/b1 和 origin/b2。\n到这里，有关本地仓库和远程仓库分支添加删除状态的同步就讲完了，希望对你有所帮助。\n","href":"/posts/branch_sync/","title":"Git示例教程 - 同步本地分支的添加删除状态到远程（或反之）"},{"content":"","href":"/tags/","title":"Tags"},{"content":"","href":"/authors/wangyuntao/","title":"wangyuntao"},{"content":"最终命令：\ngit reset HEAD^ # 上次提交内容会被保存到工作目录 git reset --hard HEAD^ # 上次提交内容会被直接丢弃 情景模拟：\n先使用下面的命令初始化一个测试用的Git仓库：\n# 初始化一个空的Git仓库 mkdir repo \u0026amp;\u0026amp; cd repo git init # 将a.txt加入到版本控制中 echo A1 \u0026gt; a.txt git add . git commit -m 1 # 将a.txt的内容修改为A2并提交 echo A2 \u0026gt; a.txt git commit -am 2 执行完上面的命令后，看下当前的Git日志：\n$ git -P log --pretty=oneline --abbrev-commit 4490479 (HEAD -\u0026gt; master) 2 bf92587 1 假设我们想撤销上次提交，但上次提交的内容不丢弃，可以使用下面的命令：\n$ git reset HEAD^ Unstaged changes after reset: M a.txt $ git -P log --pretty=oneline --abbrev-commit bf92587 (HEAD -\u0026gt; master) 1 $ cat a.txt A2 由上可见，reset命令撤销了上次提交，并把这次提交的内容保存到了工作目录。\n如果我们想撤销上次提交，并且丢弃上次提交修改的内容，可以用另外一条reset命令，这个就不在这里演示了，有兴趣的同学可以自己试下。\n","href":"/posts/undo_last_commit/","title":"Git示例教程 - 撤销上次提交"},{"content":"最终命令：\ngit checkout HEAD a.txt # 撤销对a.txt文件的修改 git restore --source=HEAD --staged --worktree a.txt # 也可以使用这个命令 情景模拟：\n先使用下面的命令初始化一个测试用的Git仓库：\n# 初始化一个空的Git仓库 mkdir repo \u0026amp;\u0026amp; cd repo git init # 将a.txt加入到版本控制中 echo A1 \u0026gt; a.txt git add . git commit -m init # 修改a.txt，并把这次修改加入到Git的staging area中 echo A2 \u0026gt;\u0026gt; a.txt git add . # 修改a.txt，不把这次修改加入到Git的staging area中 echo A3 \u0026gt;\u0026gt; a.txt 执行完上面的命令后，看下该Git仓库的当前状态：\n$ git status On branch master Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: a.txt Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git restore \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: a.txt 现在我们想撤销对a.txt文件的修改，可执行如下命令：\n$ git checkout HEAD a.txt Updated 1 path from b5ab058 $ git status On branch master nothing to commit, working tree clean $ cat a.txt A1 由上可见，checkout命令撤销了对a.txt文件的所有修改，包括staging area中的修改。\n","href":"/posts/undo_changes_to_one_file/","title":"Git示例教程 - 撤销对单个文件的修改"},{"content":"最终命令：\n$ git reset --hard # 撤销所有文件的修改（不算未进入版本控制的文件） $ git clean -fd # 删除所有未进入版本控制的文件 下面用一个例子展示下这两个命令的使用。\n先用下面的命令初始化一个测试用的Git仓库：\n$ mkdir repo $ cd repo $ git init # 初始化一个空Git仓库 $ echo a \u0026gt; f1.txt $ git add . $ git commit -m f1 # 将f1.txt加入到版本控制中 $ echo b \u0026gt; f1.txt # 修改f1.txt的内容 $ touch f2.txt # 创建新文件f2.txt，其并未进入到版本控制中 执行完上面的命令后，我们已经有了一个可供测试的Git仓库。\n再用下面的命令看下文件的变化情况：\n$ git status -s M f1.txt ?? f2.txt $ git -P diff diff --git a/f1.txt b/f1.txt index 7898192..6178079 100644 --- a/f1.txt +++ b/f1.txt @@ -1 +1 @@ -a +b 由上可见，f1.txt的内容由a变为了b，f2.txt是新创建的，还未进入到版本控制中。\n现在执行上面的撤销命令，看下是如何撤销修改的：\n$ git reset --hard HEAD is now at 5b3c640 f1 $ git status -s ?? f2.txt $ git clean -fd Removing f2.txt $ git status On branch master nothing to commit, working tree clean 由上可见，执行完reset命令后，f1.txt文件的修改被撤销，但f2.txt文件还在。\n执行完clean命令后，f2.txt文件也不在了。\n至此，两条命令撤销了对所有文件的修改，Git仓库回到了原始状态。\n","href":"/posts/undo_changes_to_all_files/","title":"Git示例教程 - 撤销对所有文件的修改"},{"content":"","href":"/page/","title":"Pages"},{"content":"","href":"/search/","title":"Search"},{"content":"","href":"/series/","title":"Series"}]
