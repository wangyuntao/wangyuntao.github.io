[{"content":"","href":"/posts/","title":"文章"},{"content":"记录下日常的技术细节\n","href":"/%E5%85%B3%E4%BA%8E/","title":"关于"},{"content":" 本博客的内容也会同步到我的微信公众号，欢迎大家关注。\n微信公众号: ytcode\n ","href":"/","title":"\u003e "},{"content":"","href":"/authors/","title":"Authors"},{"content":"","href":"/categories/","title":"Categories"},{"content":"","href":"/tags/git/","title":"Git"},{"content":"","href":"/categories/git%E7%A4%BA%E4%BE%8B%E6%95%99%E7%A8%8B/","title":"Git示例教程"},{"content":"最终命令：\ngit reset HEAD^ # 上次提交内容会被保存到工作目录 git reset --hard HEAD^ # 上次提交内容会被直接丢弃 情景模拟：\n先使用下面的命令初始化一个测试用的Git仓库：\n# 初始化一个空的Git仓库 mkdir repo \u0026amp;\u0026amp; cd repo git init # 将a.txt加入到版本控制中 echo A1 \u0026gt; a.txt git add . git commit -m 1 # 将a.txt的内容修改为A2并提交 echo A2 \u0026gt; a.txt git commit -am 2 执行完上面的命令后，看下当前的Git日志：\n$ git -P log --pretty=oneline --abbrev-commit 4490479 (HEAD -\u0026gt; master) 2 bf92587 1 假设我们想撤销上次提交，但上次提交的内容不丢弃，可以使用下面的命令：\n$ git reset HEAD^ Unstaged changes after reset: M a.txt $ git -P log --pretty=oneline --abbrev-commit bf92587 (HEAD -\u0026gt; master) 1 $ cat a.txt A2 由上可见，reset命令撤销了上次提交，并把这次提交的内容保存到了工作目录。\n如果我们想撤销上次提交，并且丢弃上次提交修改的内容，可以用另外一条reset命令，这个就不在这里演示了，有兴趣的同学可以自己试下。\n","href":"/posts/undo_last_commit/","title":"Git示例教程 - 撤销上次提交"},{"content":"最终命令：\ngit checkout HEAD a.txt # 撤销对a.txt文件的修改 git restore --source=HEAD --staged --worktree a.txt # 也可以使用这个命令 情景模拟：\n先使用下面的命令初始化一个测试用的Git仓库：\n# 初始化一个空的Git仓库 mkdir repo \u0026amp;\u0026amp; cd repo git init # 将a.txt加入到版本控制中 echo A1 \u0026gt; a.txt git add . git commit -m init # 修改a.txt，并把这次修改加入到Git的staging area中 echo A2 \u0026gt;\u0026gt; a.txt git add . # 修改a.txt，不把这次修改加入到Git的staging area中 echo A3 \u0026gt;\u0026gt; a.txt 执行完上面的命令后，看下该Git仓库的当前状态：\n$ git status On branch master Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: a.txt Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git restore \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: a.txt 现在我们想撤销对a.txt文件的修改，可执行如下命令：\n$ git checkout HEAD a.txt Updated 1 path from b5ab058 $ git status On branch master nothing to commit, working tree clean $ cat a.txt A1 由上可见，checkout命令撤销了对a.txt文件的所有修改，包括staging area中的修改。\n","href":"/posts/undo_changes_to_one_file/","title":"Git示例教程 - 撤销对单个文件的修改"},{"content":"最终命令：\n$ git reset --hard # 撤销所有文件的修改（不算未进入版本控制的文件） $ git clean -fd # 删除所有未进入版本控制的文件 下面用一个例子展示下这两个命令的使用。\n先用下面的命令初始化一个测试用的Git仓库：\n$ mkdir repo $ cd repo $ git init # 初始化一个空Git仓库 $ echo a \u0026gt; f1.txt $ git add . $ git commit -m f1 # 将f1.txt加入到版本控制中 $ echo b \u0026gt; f1.txt # 修改f1.txt的内容 $ touch f2.txt # 创建新文件f2.txt，其并未进入到版本控制中 执行完上面的命令后，我们已经有了一个可供测试的Git仓库。\n再用下面的命令看下文件的变化情况：\n$ git status -s M f1.txt ?? f2.txt $ git -P diff diff --git a/f1.txt b/f1.txt index 7898192..6178079 100644 --- a/f1.txt +++ b/f1.txt @@ -1 +1 @@ -a +b 由上可见，f1.txt的内容由a变为了b，f2.txt是新创建的，还未进入到版本控制中。\n现在执行上面的撤销命令，看下是如何撤销修改的：\n$ git reset --hard HEAD is now at 5b3c640 f1 $ git status -s ?? f2.txt $ git clean -fd Removing f2.txt $ git status On branch master nothing to commit, working tree clean 由上可见，执行完reset命令后，f1.txt文件的修改被撤销，但f2.txt文件还在。\n执行完clean命令后，f2.txt文件也不在了。\n至此，两条命令撤销了对所有文件的修改，Git仓库回到了原始状态。\n","href":"/posts/undo_changes_to_all_files/","title":"Git示例教程 - 撤销对所有文件的修改"},{"content":"","href":"/tags/","title":"Tags"},{"content":"","href":"/authors/wangyuntao/","title":"wangyuntao"},{"content":"","href":"/page/","title":"Pages"},{"content":"","href":"/search/","title":"Search"},{"content":"","href":"/series/","title":"Series"}]
